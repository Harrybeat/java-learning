CREATE DATABASE AFTER_JOINS;

USE AFTER_JOINS;


CREATE TABLE MARKET(
ID INT,CITY VARCHAR(20),SALES INT
);

INSERT INTO MARKET
VALUES
(1,"BHOPAL",100),
(2,"INDORE",200),
(3,"GOA",300);
SELECT * FROM MARKET;

-- CREATING A NEW TABLE FORM EXISTING TABLE
CREATE TABLE MP AS SELECT * FROM MARKET WHERE CITY = "BHOPAL";
SELECT * FROM MP;


-- INSERTING THE EXISTING DATA FROM ONE TABLE TO ANOTHER TABLE

INSERT INTO MP 
SELECT * FROM MARKET;

SELECT * FROM MP;


-- COPYING ONLY THE STRUCTURE NOT DATA)FROM ONE TABLE TO ANOTHER TABLE

CREATE TABLE MARKET_2 LIKE MARKET;
SELECT * FROM MARKET_2;

-- CONSTRAINTS: USED TO SPECIFY THE RULES FOR THE DATA IN A TABLE.
-- NOT NULL,AUTO INCREMENT, UNIQUE ,PRIMARY KEY, FOREIGN KEY, CHECK,DEFAULT ,INDEX

-- PRIMARY KEY : NOT NULL AND UNIQUE
-- FORGIEN KEY : NOT NULL BUT CAN REPEAT




CREATE TABLE STUDENT(
ID INT UNIQUE,
NAME VARCHAR(20) NOT NULL,
SALARY INT DEFAULT 10000,
ACCNT_NO INT PRIMARY KEY,
AGE INT CHECK(AGE>=18)
);
SELECT * FROM STUDENT;

INSERT INTO STUDENT
(ID,NAME,ACCNT_NO,AGE)
VALUES
(1,"RAM",12345,1);
SELECT * FROM STUDENT;

CREATE TABLE STUDENT_2(
ID INT AUTO_INCREMENT PRIMARY KEY,
AGE INT,
SALARY INT DEFAULT 10000,
RESULT ENUM("PASS","FAIL"),
CHECK (AGE>18 AND SALARY>5000)
);
SELECT * FROM STUDENT_2;

INSERT INTO STUDENT_2
(AGE,RESULT)
values
(20,"FAIL");
SELECT * FROM STUDENT_2;


CREATE TABLE STUDENT_3(
ID INT AUTO_INCREMENT PRIMARY KEY,
AGE INT,
SALARY INT DEFAULT 10000,
RESULT SET("PASS","FAIL"),
CHECK (AGE>18 AND SALARY>5000)
);
SELECT * FROM STUDENT_3;

INSERT INTO STUDENT_3
(AGE,RESULT)
value
(25,"FAIL,PASS");
SELECT *FROM STUDENT_3;

INSERT INTO STUDENT_3
(ID,AGE,RESULT)
value
(99,25,"PASS");
SELECT *FROM STUDENT_3;

--  VIEWS: 
/*
1.IS A VIRTUAL BASED ON THE RESULT SET OF A SQL COMMAND.\
2.IT IS LIKE A REAL TABLE CONTAIN ROWS AND COLMNS FROM THE DIFFERENT TABLES FROM THE DB
3.IT ALLOWS US TO ENCAPSULATE OR HIDE THE COMPLEXITIES IR ALLOW LIMITED READ ACCESS TO PART OF DATA.
*/

SHOW TABLES;
SELECT * FROM MP;

SELECT CITY,SUM(SALES) AS TOTAL_SALES FROM MP GROUP BY CITY HAVING TOTAL_SALES>100;

CREATE VIEW CITY_SALES AS
SELECT CITY,SUM(SALES) AS TOTAL_SALES FROM MP GROUP BY CITY HAVING TOTAL_SALES>100;
SELECT * FROM CITY_SALES;

SHOW CREATE VIEW CITY_SALES;


USE AFTER_JOINS;
SHOW TABLES;

SELECT * FROM  MP;
CREATE VIEW NEW_MP (CITY,NAME,TOTAL_SALES) AS
SELECT * FROM MP;

SELECT * FROM NEW_MP;

UPDATE MP
SET SALES=200 WHERE CITY="BHOPAL";
SET SQL_SAFE_UPDATES = 0;
SELECT * FROM NEW_MP;

UPDATE NEW_MP
SET TOTAL_SALES = 500 WHERE CITY = 3;
SELECT * FROM NEW_MP;

ALTER VIEW NEW_mp (ID,CITY,SALES) AS
SELECT * FROM MP;

SHOW CREATE VIEW NEW_MP;


DROP  VIEW NEW_mp;
select * from mp;

-- CASE STATEMENT ALLOWS US TO PERFORM CONDITONAL LOGIC WITHIN OUR QUERY
-- THEY ARE USEFUL WHEN NEED TO PEROFORM DIFFERNT ACTION/ CONDITION BASED ON CERTAIN CONDTION

-- 1.SIMPLE CASE STATEMENT
-- 2.SEARCHED CASE STATEMENT


-- 1. SIMPLE CASE STATEMENT COMPARE AN EXPERSSION TO A SET OF CONDITON AND RETURN RESULT BASED 
-- ON TH FIRST CONDITON THAT EVALUATE TO TRUE.

-- SYNTAX
/*
CASE EXPRESSION
WHEN COND1 THEN RESULT 1
WHEN COND2 THEN RESULT 2


ESLE END_ RESULT

*/


CREATE TABLE TEACHER(
ID  INT AUTO_INCREMENT PRIMARY KEY,
NAME VARCHAR(20) NOT NULL,
SALARY INT DEFAULT 10000,
GENDER VARCHAR(20) NOT NULL,
MARRIED VARCHAR(20)
);
INSERT INTO TEACHER
(NAME ,SALARY,GENDER,MARRIED)
valueS
("RAM",25000,"M","Y"),
("RANI",15000,"F","Y"),
("RAMA",5000,"M","Y"),
("SITA",2000,"F","N"),
("SHYAM",250000,"M","N"),
("RADHA",20000,"F","Y");
SELECT * FROM TEACHER;

SELECT NAME,SALARY,
CASE   
	WHEN SALARY < 10000 THEN "LOW SAL"
	WHEN SALARY < 20000 THEN "MID SAL"
	ELSE "HIGH SAL"
END AS SAL_CATEGORY
FROM TEACHER;
SELECT * FROM TEACHER;

ALTER TABLE TEACHER
ADD COLUMN SAL_CATEGORY VARCHAR(20);

UPDATE TEACHER
SET SAL_CATEGORY = 
CASE
    WHEN SALARY < 10000 THEN "LOW SAL"
	WHEN SALARY < 20000 THEN "MID SAL"
	ELSE "HIGH SAL"
END;

SELECT * FROM TEACHER;

ALTER TABLE TEACHER
ADD COLUMN PREFIX VARCHAR(20);

SELECT * FROM TEACHER;

UPDATE TEACHER
SET PREFIX = 
CASE 
     WHEN GENDER = "F" AND MARRIED ='Y' THEN "MRS." 
     WHEN GENDER = "F" AND MARRIED ='N' THEN "MISS."
     ELSE "MR."
END;
SELECT * FROM TEACHER;


/*
ALLOW US TO NEST ONE QUERY (INNER QUERY ) INSIDE ANOTHER )
(QUERY QUERY) THE REST OF INNER QUERY IS USED BY OUTER QUERY TO PERFORM FURTHER OPERATIONS.
SYNTAX;
(SELECT COL1,COL2
FROM TABLE1 WEHERR COLOUMN IN 
SELECT  COL1,COL2 FROM TABLE2 WHERE) 
*/

SELECT * FROM TEACHER;
SELECT AVG(SALARY) FROM TEACHER;


SELECT * FROM TEACHER
WHERE SALARY>( SELECT AVG(SALARY) FROM TEACHER);


SELECT NAME,SALARY,(SELECT AVG(SALARY) FROM TEACHER) AS AVG_SAL FROM TEACHER;

-- SOME EXIT ANY ALL. 


use after_join;
create table department(
dept_id int,
dept_name varchar(20)
);
select * from department;
insert into department
values
(1,"HR"),
(2,"IT"),
(3,"SALES");

CREATE TABLE EMPLOYEES(
EMP_ID INT PRIMARY KEY,
NAME VARCHAR(20),
SALARY INT,
DEPT_ID int
);
INSERT INTO EMPLOYEES
VALUES
(1,"RAM",5000,1),
(2,"RAMA",1000,2),
(3,"SHAYAM",2000,2),
(4,"SHAYM",10000,3);

CREATE TABLE PROJECTS(
PROJ_ID INT PRIMARY KEY,
PROJ_NAME VARCHAR(20),
DEPARTMENT_ID INT
);
INSERT INTO PROJECTS
VALUES 
(1,"LEADS",1),
(2,"WEBSITE",2),
(3,"SALES CAMPAIGN",3);
SELECT * FROM PROJECTS;
select * from department;
SELECT * FROM EMPLOYEES;


SELECT * FROM EMPLOYEES WHERE DEPT_ID IN (SELECT DEPARTMENT_ID FROM PROJECTS);

-- RETREIVE THE ID AND NAME OF THE EMPLOYEES WHOSE DEPARTMENT IS "IT"

SELECT * FROM EMPLOYEES
 WHERE DEPT_ID IN 
(SELECT DEPT_ID FROM  DEPARTMENT WHERE DEPT_NAME ="IT");

SELECT * FROM PROJECTS;
SELECT * FROM DEPARTMENT;


SELECT * FROM EMPLOYEES WHERE DEPT_ID IN
(SELECT DEPT_ID FROM DEPARTMENT
WHERE DEPT_NAME ="it" AND DEPT_ID in
(SELECT DEPT_ID FROM PROJECTS));


-- DELIMETER
/*
USED TO CHANGE THE DEFAULT DELIMITER SUED IN SQL STATMENT 
IT IS PARIICULARY USEFUL WHEN DEFINING STORED PRODEDURE ,TRIGGERS,
OR FUNCITON THAT CONTAIN MULTIPLE SQL STATMENT
BY DEFAULT MYSQL USE SEMICOLON(;) AS THAT STATMENTS DELIMITER.





DECLARE STATMENTS : USED WITHIN THE STORED PROCEDURE TO DECLARE
AND DEFINE VARIABLE IT ALLOWS YOU TO CREATE VARIABLE THAT CAN 
BE USED TO STORE AND MANIPULATES THE DATA DURING THE executION
OF THE STORED PROCEDURES.alter
SYNATX : DECLARE VARIABLE_NAME<DATA TYPE><DEFAULT VALUES>;

/*

/*   STORED PROCEDURE
SET OF SQL STATMENT STORED IN THE DB AND CAN BE EXECUTED
REPEATEDLY
THEY PROVIDE A WAY TO ENCAPSULATE AND REUSE THE SQL LOGIC.
THEY CAN ACCEPT INPUT AND OUTPUT PARAMETERS AS WELL.
 
 
 SUM ON ALL ANY EXIT AND DATA TYPE
*/
DELIMITER //
CREATE PROCEDURE CALCULATE_TAX(IN INVOICE_AMOUNT DECIMAL(10,2))
BEGIN   
     DECLARE TAX_RATE DECIMAL(5,2);
     DECLARE TAX_AMOUNT DECIMAL(10,2);
     SET TAX_RATE = 0.15;
     SET TAX_AMOUNT = INVOICE_AMOUNT * TAX_RATE;
     
     
     SELECT TAX_AMOUNT;
     
END //
DELIMITER ;

CALL  CALCULATE_TAX(1000);

DELIMITER //
CREATE PROCEDURE MUTILPLE_TABLES()
BEGIN
     SELECT * FROM EMPLOYEES;
     SELECT * FROM DEPARTMENT;
     SELECT * FROM PROJECTS;
     
END //
DELIMITER ;

CALL MUTILPLE_TABLES()







